"use strict";

const md5 = require('blueimp-md5');

const ast = require('../utils/astConstants');

const defaultAttributeName = "qa-id";

const defaultPrefix = "qa-id";

const defaultDivider = "_";

const defaultHashMaxLength = null;

const unknownJsxExpression = "UNKNOWN_JSX_EXPRESSION";

const unknownAttributeValue = "UNKNOWN_ATTRIBUTE_VALUE";

const objectExpressionValue = 'OBJECT_EXPRESSION_VALUE';

const getErrorMsg = attributeName => `${attributeName} attribute should be filled`;

const getAttributeValue = attribute => {
  const getJSXExpressionValue = expression => {
    switch (expression.type) {
      case ast.IDENTIFIER:
        return expression.name;
      case ast.LITERAL:
        return expression.raw;
      case ast.ARRAY_EXPRESSION:
        const str = expression.elements
            .map(getJSXExpressionValue)
            .join(', ');
        return `[${str}]`;
      case ast.OBJECT_EXPRESSION:
        return objectExpressionValue;
      case ast.CALL_EXPRESSION:
        return expression.callee.name;
      default:
        return unknownJsxExpression;
    }
  };

  if (!attribute.value)
    return null;
  switch (attribute.value.type) {
    case ast.LITERAL:
      return attribute.value.raw;
    case ast.JSX_EXPRESSION_CONTAINER:
      return getJSXExpressionValue(attribute.value.expression);
    default:
      return unknownAttributeValue;
  }
};

const generateIdValue = (jsxNode, prefix, divider, hashMaxLength) => {
  const jsxNodeName = jsxNode.name.name;
  const attributes =
      jsxNode.attributes
          .map(attr => `${attr.name.name}_${getAttributeValue(attr)}`)
          .join(",");
  const selfClosing = jsxNode.selfClosing;
  const hash = md5(`${jsxNodeName}_${attributes}_${selfClosing}`);
  return `${prefix}${divider}${hashMaxLength ? hash.substring(0, hashMaxLength) : hash}`;
};


const checkContext = context => {
  const options = context.options[0] || {};
  const attributeName = (options.attribute || defaultAttributeName).toString();
  const prefix = (options.prefix || defaultPrefix).toString();
  const divider = (options.divider || defaultDivider).toString();
  const hashMaxLength = (options.hashMaxLength || defaultHashMaxLength);

  const checkJSXAttribute = (rootNode, attribute) => {
    const attributeNode = attribute.name;

    // if id value is not present, report it as an error
    if (attributeNode.name === attributeName && !attribute.value) {
      reportError(rootNode, attributeNode)
    }
  };

  const reportError = (rootNode, attributeNode) => {
    context.report({
      node: attributeNode,
      message: getErrorMsg(attributeNode.name),
      fix: fixer => {
        const idValue = generateIdValue(rootNode, prefix, divider, hashMaxLength);
        return fixer.insertTextAfter(attributeNode, `="${idValue}"`)
      }
    })
  };


  return {
    // checking only JSX constructions
    JSXOpeningElement: jsxNode => {
      jsxNode.attributes.forEach(attribute => checkJSXAttribute(jsxNode, attribute))
    }
  }
};

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: 'Detects "id" attributes and fills empty ones with autogenerated hash values',
      category: "Fill me in",
      recommended: false
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          attribute: {
            type: "string"
          },
          prefix: {
            type: "string"
          },
          divider: {
            type: "string"
          },
          hashMaxLength: {
            type: "integer",
            minimum: 1
          }
        },
        additionalProperties: false
      }
    ]
  },
  create: checkContext
};
